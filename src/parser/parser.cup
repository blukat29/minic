/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package parser;
import java_cup.runtime.*;
import ast.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer s;
    Parser(Lexer s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, COMMA, EQUALS, COLON,
                    LBRACKET, RBRACKET, LPAREN, RPAREN, LBRACE, RBRACE,
                    RETURN, WHILE, DO, FOR, IF, ELSE, SWITCH, CASE, BREAK, DEFAULT;
terminal String     TYPE, ID;
terminal Integer    INTNUM;

/* Non terminals */
non terminal            Program;
non terminal            DeclList;
non terminal            FuncList;
non terminal            Declaration;
non terminal            IdentList;
non terminal            identifier;
non terminal            Function;
non terminal            ParamList;
non terminal            CompoundStmt;
non terminal            StmtList;
non terminal            Stmt;
non terminal            AssignStmt;
non terminal            Assign;
non terminal            CallStmt;
non terminal            Call;
non terminal            RetStmt;
non terminal            WhileStmt;
non terminal            ForStmt;
non terminal            IfStmt;
non terminal            SwitchStmt;
non terminal            CaseList;
non terminal            Expr;
non terminal            ArgList;
non terminal            CaseBlockList;
non terminal            CaseBlock;
non terminal            DefaultBlock;

precedence nonassoc IF;
precedence nonassoc ELSE;

/* Top level grammar rules */
Program      ::= DeclList FuncList
               | DeclList
               | FuncList
               |
               ;
DeclList     ::= Declaration
               | DeclList Declaration
               ;
FuncList     ::= Function
               | FuncList Function
               ;

/* Variable declarations */
Declaration  ::= TYPE IdentList SEMI
               ;
IdentList    ::= identifier
               | IdentList COMMA identifier
               ;
identifier   ::= ID
               | ID LBRACKET INTNUM RBRACKET
               ;

/* Function definition */
Function     ::= TYPE ID LPAREN RPAREN CompoundStmt
               | TYPE ID LPAREN ParamList RPAREN CompoundStmt
               ;
ParamList    ::= TYPE ID
               | ParamList COMMA TYPE ID
               ;

/* Statements */
CompoundStmt ::= LBRACE StmtList RBRACE
               | LBRACE DeclList StmtList RBRACE
               ;
StmtList     ::= StmtList Stmt
               |
               ;
Stmt         ::= SEMI
               | AssignStmt
               | CallStmt
               | RetStmt
               | WhileStmt
               | ForStmt
               | IfStmt
               | SwitchStmt
               | CompoundStmt
               ;

/* Assignments */
AssignStmt   ::= Assign SEMI
               ;
Assign       ::= ID EQUALS Expr
               | ID LBRACKET Expr RBRACKET EQUALS Expr
               ;

/* Call statements */
CallStmt     ::= Call SEMI
               ;
Call         ::= ID LPAREN RPAREN
               | ID LPAREN ArgList RPAREN
               ;
ArgList      ::= Expr
               | ArgList COMMA Expr
               ;

/* Control Structures */
RetStmt      ::= RETURN SEMI
               | RETURN Expr SEMI
               ;
WhileStmt    ::= WHILE LPAREN Expr RPAREN Stmt
               | DO Stmt WHILE LPAREN Expr RPAREN SEMI
               ;
ForStmt      ::= FOR LPAREN Assign SEMI Expr SEMI Assign RPAREN Stmt
               ;
SwitchStmt   ::= SWITCH LPAREN identifier RPAREN LBRACE CaseList RBRACE
               ;
CaseList     ::= CaseBlockList
               | CaseBlockList DefaultBlock
               ;
CaseBlockList ::= CaseBlockList CaseBlock
                |
                ;
CaseBlock    ::= CASE INTNUM COLON StmtList
               | CASE INTNUM COLON StmtList BREAK SEMI
               ;
DefaultBlock ::= DEFAULT COLON StmtList
               | DEFAULT COLON StmtList BREAK SEMI
               ;

/* Shift/Reduce conflict between two cases. */
/* Assigned precedence IF < IF-ELSE to resolve the ambiguity. */
IfStmt       ::= IF LPAREN Expr RPAREN Stmt            %prec IF
               | IF LPAREN Expr RPAREN Stmt ELSE Stmt
               ;

/* Expressions */
Expr         ::= ID
               | INTNUM
               ;
