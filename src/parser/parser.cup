package parser;
import java_cup.runtime.*;

import ast.*;

parser code {:
    public Parser(Lexer lexer, ComplexSymbolFactory sf) {
      super(lexer, sf);
    }
:}

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, COMMA, EQUALS, COLON,
                    LBRACKET, RBRACKET, LPAREN, RPAREN, LBRACE, RBRACE,
                    RETURN, WHILE, DO, FOR, IF, ELSE, SWITCH, CASE, BREAK, DEFAULT,
                    MINUS, TIMES, DIVIDE, PLUS, LT, GT, LE, GE, EQEQ, NE;
terminal TypeInfo   TYPE;
terminal IdExpr     ID;
terminal IntNum     INTNUM;
terminal FloatNum   FLOATNUM;

/* Non terminals */
non terminal Program    Program;
non terminal DeclList   DeclList;
non terminal FuncList   FuncList;
non terminal Declaration Declaration;
non terminal IdentList  IdentList;
non terminal Identifier identifier;
non terminal Function   Function;
non terminal ParamList  ParamList;
non terminal            CompoundStmt;
non terminal            StmtList;
non terminal            Stmt;
non terminal            AssignStmt;
non terminal            Assign;
non terminal            CallStmt;
non terminal            Call;
non terminal            RetStmt;
non terminal            WhileStmt;
non terminal            ForStmt;
non terminal            IfStmt;
non terminal            SwitchStmt;
non terminal            CaseList;
non terminal            Expr;
non terminal            ArgList;
non terminal            CaseBlockList;
non terminal            CaseBlock;
non terminal            DefaultBlock;

/* Precedence. From lower to higher. */
precedence nonassoc IF;
precedence nonassoc ELSE;

precedence right    EQUALS;
precedence left     EQEQ, NE;
precedence left     LT, GT, LE, GE;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;
precedence right    MINUS;
precedence left     LPAREN, RPAREN;

/* Top level grammar rules */
Program      ::= DeclList:dl FuncList:fl {: RESULT = new Program(dl, fl); :}
               | DeclList:dl             {: RESULT = new Program(dl); :}
               | FuncList:fl             {: RESULT = new Program(fl); :}
               |                         {: RESULT = new Program(); :}
               ;
DeclList     ::= Declaration:d        {: RESULT = (new DeclList()).append(d); :}
               | DeclList:l Declaration:d  {: RESULT = l.append(d); :}
               ;
FuncList     ::= Function:f               {: RESULT = (new FuncList()).append(f); :}
               | FuncList:fl Function:f   {: RESULT = fl.append(f); :}
               ;

/* Variable declarations */
Declaration  ::= TYPE:ty IdentList:il SEMI  {: RESULT = new Declaration(ty, il); :}
               ;
IdentList    ::= identifier:id                    {: RESULT = (new IdentList()).append(id); :}
               | IdentList:l COMMA identifier:id  {: RESULT = l.append(id); :}
               ;
identifier   ::= ID:id                            {: RESULT = new Identifier(id); :}
               | ID:id LBRACKET INTNUM:n RBRACKET {: RESULT = new Identifier(id, n); :}
               ;

/* Function definition */
Function     ::= TYPE:ty ID:id LPAREN RPAREN CompoundStmt:body
                    {: RESULT = new Function(ty, id); :}
               | TYPE:ty ID:id LPAREN ParamList:params RPAREN CompoundStmt:body
                    {: RESULT = new Function(ty, id, params); :}
               ;
ParamList    ::= TYPE:ty identifier:id                     {: RESULT = (new ParamList()).append(ty, id); :}
               | ParamList:pl COMMA TYPE:ty identifier:id  {: RESULT = pl.append(ty, id); :}
               ;

/* Statements */
CompoundStmt ::= LBRACE StmtList RBRACE
               | LBRACE DeclList StmtList RBRACE
               ;
StmtList     ::= StmtList Stmt
               |
               ;
Stmt         ::= SEMI
               | AssignStmt
               | CallStmt
               | RetStmt
               | WhileStmt
               | ForStmt
               | IfStmt
               | SwitchStmt
               | CompoundStmt
               ;

/* Assignments */
AssignStmt   ::= Assign SEMI
               ;
Assign       ::= ID EQUALS Expr
               | ID LBRACKET Expr RBRACKET EQUALS Expr
               ;

/* Call statements */
CallStmt     ::= Call SEMI
               ;
Call         ::= ID LPAREN RPAREN
               | ID LPAREN ArgList RPAREN
               ;
ArgList      ::= Expr
               | ArgList COMMA Expr
               ;

/* Control Structures */
RetStmt      ::= RETURN SEMI
               | RETURN Expr SEMI
               ;
WhileStmt    ::= WHILE LPAREN Expr RPAREN Stmt
               | DO Stmt WHILE LPAREN Expr RPAREN SEMI
               ;
ForStmt      ::= FOR LPAREN Assign SEMI Expr SEMI Assign RPAREN Stmt
               ;
SwitchStmt   ::= SWITCH LPAREN identifier RPAREN LBRACE CaseList RBRACE
               ;
CaseList     ::= CaseBlockList
               | CaseBlockList DefaultBlock
               ;
CaseBlockList ::= CaseBlockList CaseBlock
                |
                ;
CaseBlock    ::= CASE INTNUM COLON StmtList
               | CASE INTNUM COLON StmtList BREAK SEMI
               ;
DefaultBlock ::= DEFAULT COLON StmtList
               | DEFAULT COLON StmtList BREAK SEMI
               ;

/* Shift/Reduce conflict between two cases. */
/* Assigned precedence IF < IF-ELSE to resolve the ambiguity. */
IfStmt       ::= IF LPAREN Expr RPAREN Stmt            %prec IF
               | IF LPAREN Expr RPAREN Stmt ELSE Stmt
               ;

/* Expressions */
Expr         ::= MINUS Expr
               | Expr MINUS Expr
               | Expr TIMES Expr
               | Expr DIVIDE Expr
               | Expr PLUS Expr
               | Expr LT Expr
               | Expr GT Expr
               | Expr LE Expr
               | Expr GE Expr
               | Expr EQEQ Expr
               | Expr NE Expr
               | Call
               | INTNUM
               | FLOATNUM
               | ID
               | ID LBRACKET Expr RBRACKET
               | LPAREN Expr RPAREN
               ;
